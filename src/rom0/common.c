#include <gb/gb.h>
#include <string.h>
#include <stdlib.h>
#include <rand.h>
#include "./common.h"
#include "game_structs.h"

#define INFINITELOOP while(1) {}
#define COMBAT_LOG_STOP_RENDERING_POINT LOOP_LIMIT

#pragma bank 0

//region Global variable declarations and initialization
uint8_t GAME_STATE = STATE_TITLESCREEN;
uint8_t PREVIOUS_GAME_STATE = STATE_TITLESCREEN;
uint8_t SCENE_SUBMODE = SUBMODE_DEFAULT;
uint8_t SCENE_SUBMODE_PREV = SUBMODE_DEFAULT;

uint8_t JOYPAD_CURRENT = 0u;
uint8_t JOYPAD_PREVIOUS = 0u;

uint8_t LOOP_INDEX = 0u;
uint8_t LOOP_LIMIT = 18u;
uint8_t CURSOR_INDEX = 0u;
uint8_t CURSOR_INDEX_PREV = 0u;

uint16_t RNG_SEED;
uint8_t RNG_8 = 0u;
uint8_t TEMP_VAR_A = 0u;
uint8_t TEMP_VAR_B = 0u;
uint8_t TEMP_VAR_C = 0u;
uint8_t TEMP_VAR_D = 0u;
uint8_t TEMP_VAR_E = 0u;
uint8_t TEMP_VAR_F = 0u;
char TEMP_STRING[16];

uint8_t FRAME_COUNTER = 0u;
uint8_t ANIMATION_TICK = 0u;
uint8_t ANIMATION_TICK_SPEED = 60u;

uint8_t MUSIC_TOGGLE = 0u;
music_data_t VAR_MUSIC_DATA;
sfx_data_t VAR_SFX_DATA;

uint8_t RENDER_TARGET = RENDER_TARGET_BKG;
uint8_t BANK_BACKUP = 1u;

const unsigned char BLANK_SCREEN_TILES[256] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
unsigned char BLANK_SCREEN_MAP[] = {0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
//Dear future me: this looks so weird because my compiler is giving me grief over these having an implicit overflow.

unsigned char ITOA_STRING[4];
//endregion

//Thank you to Olivia#6275 in the gbdk2020 discord
void drawTextBkg(uint8_t x, uint8_t y, unsigned char* const text)
{
    set_bkg_tiles(x, y, strlen((char *)text), 1, text);
}

/* Converts the uint8_t to a 3-digit string with leading zeroes
 * finalStr will be modified
 */
void makeLeadingZeroString(uint8_t value, unsigned char finalStr[4]) {
    unsigned char val[4] = "000";
    uitoa(value, val, 10);
    if(value < 10u) {
        strcpy(finalStr, "00");
    } else if (value < 100u) {
        strcpy(finalStr, "0");
    }
    strcat(finalStr, val);
}

/**
 * @brief Draws a window border on the background layer with the specified size and position
 * Assigns global variables:
 * LOOP_INDEX
 * @param x 0-based tile x value of where the gauge should start
 * @param y 0-based tile y value of where the gauge should start
 * @param w 1-based tile size of how wide the window should be
 * @param h 1-based tile size of how tall the window should be
 */
void drawWindowBorder(uint8_t x, uint8_t y, uint8_t w, uint8_t h) {
    uint8_t bottomY = y + h - 1u;
    uint8_t rightX = x + w - 1u;

    //Corners
    if(RENDER_TARGET == RENDER_TARGET_BKG) {
        set_bkg_tile_xy(x, y, VRAM_WINDOW_BORDER_TOPLEFT);
        set_bkg_tile_xy(rightX, y, VRAM_WINDOW_BORDER_TOPRIGHT);
        set_bkg_tile_xy(x, bottomY, VRAM_WINDOW_BORDER_BOTTOMLEFT);
        set_bkg_tile_xy(rightX, bottomY, VRAM_WINDOW_BORDER_BOTTOMRIGHT);
    } else {
        set_win_tile_xy(x, y, VRAM_WINDOW_BORDER_TOPLEFT);
        set_win_tile_xy(rightX, y, VRAM_WINDOW_BORDER_TOPRIGHT);
        set_win_tile_xy(x, bottomY, VRAM_WINDOW_BORDER_BOTTOMLEFT);
        set_win_tile_xy(rightX, bottomY, VRAM_WINDOW_BORDER_BOTTOMRIGHT);
    }

    //Sides
    LOOP_INDEX = 1;
    LOOP_LIMIT = w - 1u;
    while(LOOP_INDEX < LOOP_LIMIT) {
        if(RENDER_TARGET == RENDER_TARGET_BKG) {
            set_bkg_tile_xy(x + LOOP_INDEX, y, VRAM_WINDOW_BORDER_TOP);
            set_bkg_tile_xy(x + LOOP_INDEX, bottomY, VRAM_WINDOW_BORDER_BOTTOM);
        } else {
            set_win_tile_xy(x + LOOP_INDEX, y, VRAM_WINDOW_BORDER_TOP);
            set_win_tile_xy(x + LOOP_INDEX, bottomY, VRAM_WINDOW_BORDER_BOTTOM);
        }
        LOOP_INDEX++;
    }
    LOOP_INDEX = 1u;
    LOOP_LIMIT = h - 1u;
    while(LOOP_INDEX < LOOP_LIMIT) {
        if(RENDER_TARGET == RENDER_TARGET_BKG) {
            set_bkg_tile_xy(x, y + LOOP_INDEX, VRAM_WINDOW_BORDER_LEFT);
            set_bkg_tile_xy(rightX, y + LOOP_INDEX, VRAM_WINDOW_BORDER_RIGHT);
        } else {
            set_win_tile_xy(x, y + LOOP_INDEX, VRAM_WINDOW_BORDER_LEFT);
            set_win_tile_xy(rightX, y + LOOP_INDEX, VRAM_WINDOW_BORDER_RIGHT);
        }
        LOOP_INDEX++;
    }
}

//region Banked data manipulation functions
/**
 * @brief Taken from the gbdk2020 docs as suggested by toxa.
 * @param first_tile
 * @param nb_tiles
 * @param data
 * @param bank
 */
void set_banked_data(uint8_t first_tile, uint8_t nb_tiles, const uint8_t *data, uint8_t bank) NONBANKED {
    uint8_t _save = _current_bank;
    SWITCH_ROM(bank);
    set_bkg_data(first_tile, nb_tiles, data);
    SWITCH_ROM(_save);
}

/**
 * @brief A wrapper for using memcpy with banks based on set_banked_data()
 * @param dest Address of where you want your data to go
 * @param src Address of what data you want to copy
 * @param len Length of the data you want to copy
 * @param bank Bank where the data you want to copy lives
 */
void cpy_banked_data(void * dest, const void * src, size_t len, uint8_t bank) NONBANKED {
    uint8_t _save = _current_bank;
    SWITCH_ROM(bank);
    memcpy(dest, src, len);
    SWITCH_ROM(_save);
}

/**
 * @brief A wrapper for using set_bkg_tiles() with banks based on set_banked_data() above.
 * @param x_pos The tile x position index on the screen you want to start writing at
 * @param y_pos The tile y position index on the screen you want to start writing at
 * @param width The width in tiles of the square of tile map you want to write
 * @param height The height in tiles of the square of tile map you want to write
 * @param tile_data A pointer to the tile data you want to write
 * @param bank The bank where the tile data you want to write resides
 */
void set_banked_tiles(uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, const uint8_t * tile_data, uint8_t bank) NONBANKED {
    uint8_t _save = _current_bank;
    SWITCH_ROM(bank);
    set_bkg_tiles(x_pos, y_pos, width, height, tile_data);
    SWITCH_ROM(_save);
}

/**
 * @brief What if set_banked_tiles but also we called set_bkg_based_tiles instead of set_bkg_tiles?
 * @param x_pos The tile x position index on the screen you want to start writing at
 * @param y_pos The tile y position index on the screen you want to start writing at
 * @param width The width in tiles of the square of tile map you want to write
 * @param height The height in tiles of the square of tile map you want to write
 * @param tile_data A pointer to the tile data you want to write
 * @param bank The bank where the tile data you want to write resides
 * @param base_tile The index you need to add to the tile map array
 */
void set_based_banked_tiles(uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, const uint8_t * tile_data, uint8_t bank, uint8_t base_tile) NONBANKED {
    uint8_t _save = _current_bank;
    SWITCH_ROM(bank);
    set_bkg_based_tiles(x_pos, y_pos, width, height, tile_data, base_tile);
    SWITCH_ROM(_save);
}
//endregion